#include "test/opengl_test/BillboardActor.h"
#include "test/opengl_test/Game.h"
#include "test/opengl_test/Pawn.h"

#include <exception>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>

#include <csignal>

// linux
#include <execinfo.h>
#include <signal.h>
#include <unistd.h>


// delet dis
#include "engine/gl/GlWrapper.h"
#include "engine/Def.h"
#include "pt/math.h"
#include "engine/Services.h"
#include "engine/DrawingControl.h"

// callback to call when encountering specific process signal
void
Handler(int sig )
{
    size_t  size;
    const size_t  maxsize = 256;
    void*   array[maxsize];

    // get void*'s for all entries on the stack
    size = backtrace( array, maxsize );

    // print out all the frames to stderr
    fprintf(stderr, "---------- Stack trace ----------\n" );
    fprintf(stderr, "Error: signal %d:\n", sig);
    backtrace_symbols_fd(array, size, STDERR_FILENO);
    fprintf(stderr, "\n");
    exit(1);
}


void
AssertHander( int sig ){
    std::cerr << "Assertion failed!\n";
    Handler( sig );
};

void
SegFaultHandler(int sig ){
    std::cerr << "Segmentation fault!\n";
    Handler( sig );
};

#include <thread>

int
main( int argc, char *argv[] )
{
    std::signal( SIGSEGV, SegFaultHandler );
    std::signal( SIGABRT, AssertHander );

    //signal( SIGSEGV, SegFaultHandler );   // install our handler
    //signal( SIGABRT, AssertHander );   // install our handler

    // shutdown after running for 3 seconds
/*
    std::thread t1( []{
        PT_LOG_OUT( "Scheduling program exit after running for 3 seconds" );
        pt::Sleep( 3000 );
        PT_LOG_OUT( "3 seconds: Exiting program" );
        exit(1);
    } );
*/

    try{
        Game game( argc, argv );
        game.Initialize();


        const char* TestVertexShader = R"(
            #version 330
            precision highp float;

            uniform float       f;
            uniform mat4        M;
            uniform mat4        PVM;

            layout(location = 0) in vec3 in_vPos;
            out     vec3    vPos;

            void main(){
                gl_Position = PVM * vec4(in_vPos, 1.0f);
            }
        )";
        const char* TestFragmentShader = R"(
            #version 330
            precision highp float;

            uniform mat4        M;

            in      vec3    vPos;
            out     vec4    FragColor;

            void main(){
                FragColor = vec4( 1.0f, 1.0f, 1.0f, 1.0f );
            }
        )";

/*
        auto window = SDL_CreateWindow( "asd",
                                        200, 200,
                                        1280, 720,
                                        SDL_WINDOW_OPENGL );
        auto glContext = SDL_GL_CreateContext( window );
*/
        using namespace engine;

        auto window = game.GetMainWindow();
        SDL_ShowWindow( window );

        gl::Clear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT );
        gl::ClearColor( 0.2f, 0.2f, 0.2f, 1.0f );
        SDL_GL_SwapWindow( window );

        GLuint myProgram = gl::CreateProgram();
        GLuint vShader = gl::CreateShader( gl::ShaderType::VERTEX_SHADER );
        GLuint fShader = gl::CreateShader( gl::ShaderType::FRAGMENT_SHADER );

        PT_LOG_OUT( "prog: " << myProgram );
        PT_LOG_OUT( "vsh: " << vShader );
        PT_LOG_OUT( "fsh: " << fShader );


        GLint vLen = strlen( TestVertexShader );
        GLint fLen = strlen( TestFragmentShader );

        gl::ShaderSource( vShader, 1, &TestVertexShader, &vLen );
        gl::ShaderSource( fShader, 1, &TestFragmentShader, &fLen );

        gl::CompileShader( vShader );
        {
            auto mHandle = vShader;
            GLint success = false;
            gl::GetShaderiv( mHandle, GL_COMPILE_STATUS, &success);
            if( GL_FALSE == success ){
                PT_LOG_ERR( "Failed to compile vertex shader" );
                gl::PrintShaderInfoLog( mHandle );
                return 1;
            }

        }

        gl::CompileShader( fShader );
        {
            auto mHandle = fShader;
            GLint success = false;
            gl::GetShaderiv( mHandle, GL_COMPILE_STATUS, &success);
            if( GL_FALSE == success ){
                PT_LOG_ERR( "Failed to compile fragment shader" );
                gl::PrintShaderInfoLog( mHandle );
                return 1;
            }

        }
        PT_LOG_OUT( "Shaders are compiled correctly" );


        gl::AttachShader( myProgram, vShader );
        gl::AttachShader( myProgram, fShader );


        gl::LinkProgram( myProgram );
        {
            auto mHandle = myProgram;
            GLint success = 0;
            gl::GetProgramiv( mHandle, GL_LINK_STATUS, &success );
            if( GL_FALSE == success ) {
                PT_LOG_ERR( "Error while linking shader program" );
                gl::PrintProgramInfoLog( mHandle );
                return 1;
            }
            PT_LOG_DEBUG( "Successfuly linked ShaderProgram(" << mHandle << ")'" );
        }

        if( gl::ValidateProgram( myProgram ) ){
            PT_LOG_DEBUG( "ShaderProgram is valid" );
        }
        gl::UseProgram( myProgram );

        {
        GLint loc_f  = gl::GetUniformLocation( myProgram, "f" );
        GLint locM   = gl::GetUniformLocation( myProgram, "M" );
        GLint locMVP = gl::GetUniformLocation( myProgram, "MVP" );
        GLint locVP  = gl::GetUniformLocation( myProgram, "VP" );

        }
        GLint loc_f  = glGetUniformLocation( myProgram, "f" );
        GLint locM   = glGetUniformLocation( myProgram, "M" );
        GLint locMVP = glGetUniformLocation( myProgram, "MVP" );
        GLint locVP  = glGetUniformLocation( myProgram, "VP" );
        PT_LOG_OUT( "f: " << loc_f );
        PT_LOG_OUT( "M: " << locM );
        PT_LOG_OUT( "MVP: " << locMVP );
        PT_LOG_OUT( "VP: " << locVP );

        int timeout = 10;
        while( 0 < timeout ){
            std::cerr << "\rClosing in " << timeout << "...     ";
            pt::Sleep( 1000 );
            --timeout;
        }


// szerezd be a uniformokat
//  nézd meg a uniform vector query ami elcseszi-e
        // vmiért -1-et adogat vissza a getuniformlocation




        //game.Execute();
    }catch( const std::exception& e ){
        PT_LOG_ERR( "An exception was thrown. \nReason: "
                    << e.what() );
    }
    catch(...){
        PT_LOG_ERR( "An unknown exception was thrown!" );
    }

    return 0;
}
